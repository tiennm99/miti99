---
title: "Newsletter #23"
date: 2025-05-10
tags: [ "AI-Assisted", "Java", "Software Engineering", "AI", "Career Development", "Performance", "Database" ]
categories: [ "Newsletter" ]
---

*Mời bạn thưởng thức Newsletter #23.*

## [LLMs: An Operator's View](https://theengineeringmanager.substack.com/p/llms-an-operators-view)

Bài viết này cung cấp một góc nhìn thực tế về việc sử dụng LLM (Large Language Models) trong môi trường doanh nghiệp từ góc độ của người quản lý. Tác giả James Stanier chia sẻ những insights quan trọng về cách các tổ chức nên tiếp cận và tích hợp LLM vào quy trình phát triển phần mềm.

Những điểm chính trong bài viết:

* **Nâng cao năng suất phát triển**: LLM đã trở thành công cụ không thể thiếu trong bộ công cụ của developer, giúp tăng tốc độ phát triển đáng kể thông qua các tính năng như code completion, prototyping nhanh và viết test tự động.

* **Thay đổi quy mô tổ chức**: Với việc tăng năng suất từ LLM, các công ty có thể làm được nhiều việc hơn với ít người hơn. Tuy nhiên, tác giả cảnh báo về việc cân bằng giữa việc giảm nhân sự và duy trì chất lượng sản phẩm.

* **Tăng cường quy trình code review**: Với tốc độ tạo code nhanh hơn từ LLM, việc review code trở nên quan trọng hơn bao giờ hết. Cần có quy trình review chặt chẽ để đảm bảo chất lượng và bảo mật.

* **Thay đổi trong quy trình phỏng vấn**: Bài viết đề cập đến những thách thức mới trong việc đánh giá ứng viên khi LLM có thể được sử dụng trong quá trình phỏng vấn, và đề xuất các phương pháp thích ứng.

* **Chiến lược triển khai**: Tác giả nhấn mạnh tầm quan trọng của việc đào tạo team sử dụng LLM hiệu quả, bao gồm việc xác định các "champion", chia sẻ best practices và theo dõi hiệu quả sử dụng.

Bài viết kết luận rằng việc tích hợp LLM vào quy trình phát triển không còn là lựa chọn mà là yêu cầu bắt buộc để duy trì tính cạnh tranh trong ngành công nghệ hiện nay.

## [The Reality of Tech Interviews in 2025](https://newsletter.pragmaticengineer.com/p/the-reality-of-tech-interviews)

Bài viết này cung cấp một cái nhìn sâu sắc về thực trạng phỏng vấn kỹ thuật trong năm 2025, được viết bởi Evan King (cựu Staff Engineer tại Meta) và Stefan Mai (cựu Engineering Manager tại Amazon và Meta). Dựa trên kinh nghiệm thực tế từ việc giúp hàng nghìn kỹ sư chuẩn bị cho các cuộc phỏng vấn, bài viết phân tích những thay đổi đáng chú ý trong thị trường tuyển dụng công nghệ.

Những điểm chính:

* **Thị trường tuyển dụng đang phục hồi có chọn lọc**: Mặc dù số lượng việc làm đã tăng khoảng 40% so với năm ngoái, nhưng vẫn thấp hơn nhiều so với đỉnh điểm 2020-2022. Các công ty đang trở nên kỹ lưỡng hơn trong việc tuyển dụng.

* **Phân hóa theo chuyên môn**: 
  - Các vị trí liên quan đến AI, ML và Generative AI đang rất "hot"
  - Các vị trí frontend, backend truyền thống đang gặp khó khăn hơn
  - Kỹ sư full-stack được ưa chuộng hơn do khả năng đa năng

* **Thay đổi trong quy trình phỏng vấn**:
  - Tiêu chuẩn đánh giá cao hơn so với trước đây
  - Tỷ lệ "downleveling" (hạ cấp) tăng lên
  - Quá trình matching team trở thành một bước quan trọng

* **Chiến lược chuẩn bị theo cấp độ**:
  - Entry-level: Tập trung vào kỹ năng cơ bản và thực hành nhiều
  - Mid-level: Cân bằng giữa kỹ năng kỹ thuật và soft skills
  - Senior+: Tập trung vào leadership và system design
  - Engineering Manager: Chú trọng vào quản lý team và chiến lược

* **Những điểm tích cực**:
  - Các công ty Big Tech vẫn duy trì khoảng 40,000 vị trí mở
  - Lĩnh vực AI tiếp tục tăng trưởng mạnh
  - Quy trình phỏng vấn ngày càng minh bạch và có thể chuẩn bị

Bài viết kết luận rằng mặc dù thị trường việc làm đang khó khăn hơn, nhưng với sự chuẩn bị kỹ lưỡng và chiến lược phù hợp, các kỹ sư vẫn có thể tìm được vị trí phù hợp. Điều quan trọng là cần đầu tư thời gian vào việc chuẩn bị và thực hành các kỹ năng phỏng vấn.

## [Senior Developer Skills in the AI Age: Leveraging Experience for Better Results](https://manuel.kiessling.net/2025/03/31/how-seasoned-developers-can-achieve-great-results-with-ai-coding-agents/)

Bài viết này chia sẻ kinh nghiệm thực tế về cách các kỹ sư phần mềm kỳ cựu có thể tận dụng AI coding agents (như Cursor) để đạt được kết quả tốt hơn trong công việc. Tác giả Manuel Kießling, dựa trên kinh nghiệm làm việc với team của mình tại Joboo, đã xác định được ba yếu tố quan trọng để làm việc hiệu quả với AI coding assistants.

Những điểm chính:

* **Ba yếu tố quan trọng để làm việc với AI coding assistants**:
  - Yêu cầu được cấu trúc tốt (Well-structured Requirements)
  - Công cụ kiểm soát chất lượng (Tool-based Guard Rails)
  - Định hình cấu trúc file (File-based Keyframing)

* **Yêu cầu được cấu trúc tốt**:
  - Cung cấp context đầy đủ về task
  - Mô tả rõ ràng các ràng buộc và yêu cầu
  - Sử dụng các file hiện có làm ví dụ và hướng dẫn
  - Định nghĩa rõ mục tiêu và phạm vi

* **Công cụ kiểm soát chất lượng**:
  - Sử dụng các công cụ format code
  - Tích hợp linting và type checking
  - Kiểm tra bảo mật
  - Chạy test suite tự động

* **Định hình cấu trúc file**:
  - Tạo các file stub với cấu trúc cơ bản
  - Định nghĩa rõ namespace và naming conventions
  - Cung cấp các file mẫu làm tham khảo

* **Kết quả thực tế**:
  - Có thể xây dựng các tính năng hoàn chỉnh mà không cần viết code
  - Tăng tốc độ phát triển đáng kể
  - Duy trì được chất lượng code và tính toàn vẹn của kiến trúc
  - Cho phép làm việc với các tech stack mới một cách hiệu quả

Bài viết kết luận rằng kinh nghiệm và kiến thức của các kỹ sư kỳ cựu vẫn rất quan trọng trong thời đại AI, thậm chí còn quan trọng hơn để hướng dẫn và kiểm soát AI coding assistants một cách hiệu quả.

## [JEP 483: Ahead-of-Time Class Loading & Linking](https://www.morling.dev/blog/jep-483-aot-class-loading-linking/)

Bài viết này phân tích chi tiết về JEP 483, một tính năng mới trong Java 24 nhằm cải thiện thời gian khởi động của các ứng dụng Java. Tác giả Gunnar Morling đã thực hiện các thử nghiệm thực tế với Apache Kafka và Apache Flink để đánh giá hiệu quả của tính năng này.

Những điểm chính:

* **Tổng quan về JEP 483**:
  - Là một phần của Project Leyden, nhằm giảm footprint của các chương trình Java
  - Xây dựng dựa trên tính năng Application Class Data Sharing (AppCDS)
  - Cho phép load và link các class trước khi chạy ứng dụng
  - Không yêu cầu thay đổi code của ứng dụng

* **Quy trình tạo AOT cache**:
  - Yêu cầu một lần chạy training để tạo file cấu hình
  - Cần đảm bảo load đúng set các class cần thiết
  - Classpath phải nhất quán giữa lần chạy training và chạy thực tế
  - File cache được tạo ra có thể được tái sử dụng

* **Kết quả thử nghiệm với Kafka**:
  - Giảm 59% thời gian khởi động (từ 690ms xuống 285ms)
  - File cache có kích thước khoảng 66MB
  - Vẫn chậm hơn so với native binary (118ms) nhưng an toàn hơn cho production

* **Kết quả thử nghiệm với Flink**:
  - Giảm 51% thời gian khởi động (từ 1.875s xuống 0.913s)
  - Chỉ áp dụng được cho các class có sẵn của Flink
  - Chưa hỗ trợ user-defined class loaders

* **So sánh với GraalVM**:
  - GraalVM hiện tại tiên tiến hơn với full AOT compilation
  - Có thể giảm thời gian khởi động xuống vài milliseconds
  - Yêu cầu điều chỉnh code và cấu hình phức tạp hơn
  - Không hỗ trợ một số tính năng động của JVM

* **Hạn chế và triển vọng**:
  - Quy trình training hiện tại còn phức tạp
  - Có thể gặp khó khăn khi tích hợp vào container images
  - Project Leyden đang phát triển thêm các tính năng AOT khác
  - Hứa hẹn cải thiện thời gian warm-up và đạt peak performance

Bài viết kết luận rằng JEP 483 là một bước tiến quan trọng trong việc cải thiện hiệu suất của Java, đặc biệt hữu ích cho các ứng dụng cloud-native và microservices, nơi thời gian khởi động nhanh là yếu tố quan trọng.

## [Specifications in Jakarta Data](https://in.relation.to/2025/03/28/repository-specifications/)

Bài viết này của Gavin King (Hibernate) giới thiệu cách triển khai tính năng "specifications" trong Jakarta Data, một cách tiếp cận linh hoạt để xây dựng các truy vấn động trong ứng dụng Java. Mặc dù tính năng này không có sẵn trong Jakarta Data, bài viết hướng dẫn cách tự triển khai một cách đơn giản và hiệu quả.

Những điểm chính:

* **Tổng quan về Specifications**:
  - Là cách tiếp cận từ Spring Data để xây dựng truy vấn động
  - Cho phép áp dụng các điều kiện lọc một cách linh hoạt
  - Giúp giảm bớt độ phức tạp của JPA Criteria API
  - Có thể được triển khai dễ dàng trong Jakarta Data

* **Triển khai cơ bản**:
  - Sử dụng interface `JpaRepository` làm base
  - Tận dụng `BiFunction` của Java để định nghĩa specification
  - Cung cấp các phương thức `find()` và `count()`
  - Hỗ trợ type-safe thông qua JPA static metamodel

* **Ví dụ sử dụng**:
  - Tìm kiếm sách theo tiêu đề:
    ```java
    library.count((builder, book) ->
        builder.like(book.get(Book_.title), "%" + title + "%"));
    ```
  - Tìm kiếm phức tạp với nhiều điều kiện:
    ```java
    library.find((builder, book) ->
        builder.and(
            builder.like(book.get(Book_.title), "%" + title + "%"),
            builder.lower(book.join(Book_.authors).get(Author_.name))
                .equalTo(authorName.toLowerCase())
        ));
    ```

* **Tính năng nâng cao**:
  - Hỗ trợ kết hợp nhiều specifications
  - Có thể mở rộng thêm các phương thức tìm kiếm
  - Dễ dàng thêm các tính năng như sắp xếp kết quả
  - Tích hợp tốt với các tính năng khác của Jakarta Data

* **Ưu điểm**:
  - Code ngắn gọn và dễ hiểu
  - Type-safe và an toàn khi biên dịch
  - Linh hoạt trong việc xây dựng truy vấn
  - Dễ dàng mở rộng và tùy chỉnh

Bài viết kết luận rằng mặc dù Jakarta Data chưa có sẵn tính năng specifications, nhưng việc tự triển khai không khó và mang lại nhiều lợi ích. Tác giả cũng gợi ý rằng một tính năng tương tự sẽ được tích hợp trong Jakarta Data 1.1 trong tương lai.

## [There is no Vibe Engineering](https://serce.me/posts/2025-31-03-there-is-no-vibe-engineering)

Bài viết này của Sergey Tselovalnikov (SerCe) phân tích về khái niệm "vibe coding" được Andrej Karpathy đề xuất gần đây và đưa ra những nhận định sâu sắc về vai trò thực sự của kỹ sư phần mềm trong thời đại AI. Tác giả phản bác quan điểm cho rằng AI sẽ thay thế hoàn toàn vai trò của kỹ sư phần mềm.

Những điểm chính:

* **Phân biệt Coding và Engineering**:
  - Coding chỉ là viết code tại một thời điểm
  - Engineering là "programming integrated over time"
  - Engineering bao gồm việc xây dựng hệ thống có thể:
    + Chịu được điều kiện thực tế
    + Mở rộng theo nhu cầu
    + Chống lại các mối đe dọa bảo mật
    + Di chuyển và hỗ trợ dữ liệu người dùng
    + Thích ứng với yêu cầu mới trong tương lai

* **Hạn chế của Vibe Coding**:
  - Chỉ tập trung vào việc tạo prototype nhanh
  - Bỏ qua các vấn đề engineering quan trọng
  - Khó diễn đạt các yêu cầu phức tạp qua prompt
  - Khó kiểm tra chất lượng chỉ bằng việc xem kết quả cuối cùng
  - Đẩy các vấn đề engineering sang giai đoạn muộn, khi chi phí giải quyết cao

* **Tương lai của Engineering với AI**:
  - Có thể xây dựng hệ thống từ các thành phần "vibe-coded"
  - Cần đóng gói chặt chẽ các thành phần AI-generated
  - Yêu cầu testing nghiêm ngặt hơn
  - Cần profiling chi tiết và tracing
  - Sử dụng canary deployments
  - Kiểm tra tương thích protocol chặt chẽ

* **Vai trò mới của Kỹ sư**:
  - Kết hợp giữa kiến trúc sư và platform engineer
  - Tập trung vào việc thiết kế hệ thống có thể mở rộng
  - Đảm bảo khả năng tiến hóa của hệ thống
  - Giảm thời gian viết code nhưng tăng thời gian thiết kế

Bài viết kết luận rằng mặc dù "vibe coding" là một công cụ hữu ích để tạo prototype nhanh, nhưng nó không thể thay thế vai trò của kỹ sư phần mềm trong việc xây dựng và duy trì các hệ thống production-grade. Công việc thiết kế phần mềm có thể mở rộng và tiến hóa vẫn là yếu tố quan trọng, ngay cả khi cách viết code thay đổi.

## [Refining Var-Handles in Valhalla](https://cr.openjdk.org/~jrose/values/atomic-value-access-api.html)

Bài viết này của John Rose (OpenJDK) trình bày về việc cải tiến API truy cập giá trị nguyên tử trong Project Valhalla, một dự án quan trọng của Java nhằm cải thiện hiệu suất và tính linh hoạt của việc xử lý dữ liệu. Bài viết tập trung vào việc tối ưu hóa cách Java xử lý các giá trị nguyên tử và cấu trúc dữ liệu.

Những điểm chính:

* **Tổng quan về Var-Handles**:
  - Là cơ chế truy cập biến trong Java heap
  - Thực hiện các thao tác tương tự như getfield, putfield
  - Hỗ trợ các thao tác nguyên tử như CAS
  - Cần đảm bảo tính nhất quán giữa interpreter, JIT và JNI

* **Các loại Layout trong Valhalla**:
  - `REFERENCE`: Biến là managed pointer (32 hoặc 64 bits, nullable)
  - `NON_ATOMIC_FLAT`: Biến có nhiều subfield, thường lớn hơn 64 bits
  - `ATOMIC_FLAT`: Biến đóng gói trong 64 bits, có thể có subfield nhỏ
  - `NULLABLE_ATOMIC_FLAT`: Tương tự ATOMIC_FLAT nhưng có thêm null flag
  - `NULLABLE_NON_ATOMIC_FLAT`: Tương tự NON_ATOMIC_FLAT với null flag
  - `BUFFERED`: Trường hợp đặc biệt cho giá trị read-only

* **Cải tiến API**:
  - Thêm các phương thức mới để xử lý giá trị nguyên tử
  - Tách biệt logic xử lý field và thao tác memory
  - Sử dụng buffer riêng tư để đảm bảo thread safety
  - Hỗ trợ tốt hơn cho việc xử lý null và atomic operations

* **Tối ưu hóa hiệu suất**:
  - Giảm overhead khi truy cập biến
  - Tăng hiệu suất cho các thao tác nguyên tử
  - Cải thiện khả năng tương thích với GC
  - Tối ưu hóa việc xử lý các giá trị phức tạp

* **Tính năng mới**:
  - Hỗ trợ tốt hơn cho value types
  - Cải thiện khả năng xử lý các cấu trúc dữ liệu phức tạp
  - Tăng cường bảo mật và thread safety
  - Đơn giản hóa việc triển khai các thao tác nguyên tử

Bài viết kết luận rằng những cải tiến này sẽ giúp Java xử lý hiệu quả hơn các giá trị nguyên tử và cấu trúc dữ liệu phức tạp, đồng thời cung cấp một API an toàn và dễ sử dụng hơn cho các nhà phát triển. Đây là một bước tiến quan trọng trong việc cải thiện hiệu suất và khả năng mở rộng của Java.
