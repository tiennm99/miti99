---
title: "Newsletter #44"
date: 2025-08-03
tags:
  [
    "AI-Assisted",
    "Công cụ lập trình",
    "Cursor",
    "Quy trình phát triển",
    "Kỹ năng chuyên môn",
  ]
categories: ["Newsletter"]
---

_Như đã đề cập, hôm nay mình sẽ thử Newsletter với Roo Code. Các post tiếp theo sẽ dùng Roo Code + Qwen 3 Coder. Mời bạn thưởng thức Newsletter #44._

## [Cursor Unveils Game-Changing Web App for AI Coding Agents](https://opentools.ai/news/cursor-unveils-game-changing-web-app-for-ai-coding-agents)

Cursor, công cụ lập trình AI nổi tiếng, vừa công bố một ứng dụng web mới mang tính cách mạng cho các agent lập trình AI. Đây là bước tiến quan trọng trong việc làm cho các công cụ AI trở nên dễ tiếp cận và hiệu quả hơn cho các lập trình viên.

### Tính năng nổi bật

Ứng dụng web mới của Cursor cho phép các lập trình viên tương tác với các agent AI một cách trực quan hơn thông qua giao diện web. Thay vì chỉ làm việc trong môi trường trình soạn thảo code, giờ đây người dùng có thể quản lý và giám sát các agent AI của họ thông qua một dashboard tập trung.

### Lợi ích cho lập trình viên

1. **Tăng năng suất**: Các agent AI có thể thực hiện các tác vụ lập trình phức tạp một cách tự động, giải phóng lập trình viên khỏi các công việc lặp đi lặp lại.

2. **Dễ sử dụng hơn**: Giao diện web trực quan giúp người mới bắt đầu dễ dàng tiếp cận và sử dụng các công cụ AI mạnh mẽ.

3. **Tích hợp liền mạch**: Ứng dụng web tích hợp chặt chẽ với trình soạn thảo Cursor, cho phép chuyển đổi mượt mà giữa các môi trường làm việc.

### Tác động đến ngành công nghiệp

Việc Cursor phát hành ứng dụng web này đánh dấu một bước tiến quan trọng trong việc phổ biến các công cụ lập trình AI. Bằng cách làm cho các agent AI trở nên dễ tiếp cận hơn, Cursor đang giúp thu hẹp khoảng cách giữa công nghệ AI tiên tiến và các lập trình viên thông thường.

Đây là một tín hiệu cho thấy ngành công nghiệp phát triển phần mềm đang chuyển mình mạnh mẽ dưới tác động của AI, với các công cụ ngày càng thông minh và dễ sử dụng hơn.

## [The Heart of Software Engineering Still Beats](https://annievella.com/posts/the-heart-of-software-engineering-still-beats/)

Trong thời đại mà AI và các công cụ tự động hóa đang thay đổi cách chúng ta phát triển phần mềm, bài viết này nhắc nhở chúng ta rằng trái tim của kỹ thuật phần mềm vẫn đang đập - đó là con người và tư duy sáng tạo của họ.

### Tư duy thiết kế vẫn là cốt lõi

Dù AI có thể viết code nhanh hơn con người, nhưng việc đưa ra quyết định thiết kế, hiểu rõ nhu cầu người dùng và tạo ra giải pháp phù hợp vẫn cần đến tư duy con người. AI có thể hỗ trợ trong việc thực hiện, nhưng không thể thay thế hoàn toàn vai trò của con người trong việc xác định vấn đề và định hướng giải pháp.

### Sự cân bằng giữa công nghệ và con người

Bài viết nhấn mạnh rằng thành công trong phát triển phần mềm không chỉ đến từ việc áp dụng công nghệ tiên tiến, mà còn từ khả năng hiểu và kết nối với con người - cả người dùng cuối và đồng nghiệp trong nhóm. Kỹ năng giao tiếp, khả năng giải quyết vấn đề phức tạp và tư duy hệ thống vẫn là những yếu tố quan trọng.

### Bài học cho lập trình viên hiện đại

1. **Phát triển kỹ năng mềm**: Kỹ năng giao tiếp, làm việc nhóm và hiểu biết về nghiệp vụ ngày càng quan trọng hơn kỹ năng viết code thuần túy.

2. **Tập trung vào giải quyết vấn đề**: Thay vì chỉ tập trung vào việc viết code, hãy tập trung vào việc hiểu vấn đề và tìm ra giải pháp tối ưu.

3. **Giữ vững tư duy phản biện**: Trong thế giới đầy rẫy các công cụ và framework, khả năng đánh giá và lựa chọn công nghệ phù hợp là điều cần thiết.

Điều này nhắc nhở chúng ta rằng dù công nghệ có phát triển đến đâu, yếu tố con người vẫn là trung tâm của mọi thành công trong phát triển phần mềm.

## [Expert Generalist](https://martinfowler.com/articles/expert-generalist.html)

Trong ngành phát triển phần mềm, vai trò của "chuyên gia đa năng" (expert generalist) đang ngày càng trở nên quan trọng. Đây là những người có kiến thức rộng rãi về nhiều lĩnh vực nhưng vẫn duy trì được chuyên môn sâu trong một số lĩnh vực cụ thể. Bài viết của Martin Fowler khám phá cách tiếp cận này có thể mang lại lợi ích cho cả cá nhân và tổ chức.

### Khái niệm về chuyên gia đa năng

Chuyên gia đa năng không phải là người biết một chút về mọi thứ, mà là những người có khả năng hiểu sâu về một hoặc hai lĩnh vực, đồng thời có kiến thức đủ tốt về các lĩnh vực khác để có thể giao tiếp và hợp tác hiệu quả. Điều này đặc biệt quan trọng trong các môi trường phát triển phần mềm hiện đại, nơi các dự án thường yêu cầu sự kết hợp của nhiều công nghệ và kỹ năng khác nhau.

### Lợi ích cho cá nhân

1. **Tăng cơ hội nghề nghiệp**: Các chuyên gia đa năng thường linh hoạt hơn trong việc thích nghi với các vai trò khác nhau và có thể đóng góp vào nhiều khía cạnh của dự án.

2. **Hiểu biết toàn diện**: Việc hiểu rõ nhiều khía cạnh của hệ thống giúp đưa ra quyết định thiết kế tốt hơn và giải quyết vấn đề hiệu quả hơn.

3. **Khả năng lãnh đạo**: Kiến thức rộng giúp các chuyên gia đa năng trở thành những người dẫn dắt tự nhiên trong các nhóm phát triển.

### Lợi ích cho tổ chức

1. **Tăng cường giao tiếp**: Các chuyên gia đa năng có thể đóng vai trò cầu nối giữa các nhóm chuyên môn khác nhau, cải thiện sự hợp tác và giảm thiểu hiểu lầm.

2. **Tăng khả năng phục hồi**: Khi một chuyên gia chuyên sâu vắng mặt, các chuyên gia đa năng có thể đảm nhận vai trò của họ, giảm thiểu tác động đến tiến độ dự án.

3. **Cải thiện thiết kế hệ thống**: Với kiến thức về nhiều lĩnh vực, các chuyên gia đa năng có thể đưa ra những quyết định thiết kế toàn diện hơn.

### Cách nuôi dưỡng các chuyên gia đa năng

Để phát triển các chuyên gia đa năng trong tổ chức, cần có chiến lược rõ ràng:

- Khuyến khích học tập liên tục và khám phá các lĩnh vực mới
- Tạo cơ hội để các thành viên trong nhóm làm việc trên các dự án đa dạng
- Thiết lập hệ thống mentoring để chia sẻ kiến thức giữa các chuyên gia
- Đánh giá hiệu suất dựa trên cả chuyên môn sâu và khả năng đa dạng

Xu hướng này phản ánh sự thay đổi trong ngành công nghiệp phần mềm, nơi mà sự phức tạp ngày càng tăng đòi hỏi các chuyên gia có tầm nhìn toàn diện hơn.

_Trên đây là các bài dùng Roo Code với Qwen 3 Coder, nhìn chung thì tương đối chậm và tốn khá nhiều request. Sau đây mình sẽ dùng thử Roo Code với Kimi K2_

## [Writing code was never the bottleneck](https://ordep.dev/posts/writing-code-was-never-the-bottleneck)

Trong thế giới phát triển phần mềm, nhiều người thường cho rằng việc viết code là phần chậm nhất và tốn kém nhất của quy trình. Tuy nhiên, bài viết này chỉ ra rằng quan điểm này có thể không còn đúng trong thực tế hiện đại.

### Quan điểm truyền thống vs thực tế

Trong quá khứ, khi tài nguyên máy tính còn hạn chế và các công cụ hỗ trợ chưa phát triển, việc viết code có thể là một nút thắt cổ chai. Nhưng ngày nay, với sự xuất hiện của các công cụ lập trình hiện đại, thư viện phong phú và hạ tầng đám mây, vấn đề thường nằm ở những khía cạnh khác của quy trình phát triển.

### Những yếu tố thực sự ảnh hưởng đến hiệu suất

1. **Thiết kế hệ thống**: Quyết định thiết kế sai lầm ở giai đoạn đầu có thể gây ra vấn đề nghiêm trọng về hiệu suất mà việc viết code nhanh hay chậm không thể khắc phục.

2. **Quản lý dữ liệu**: Việc xử lý, lưu trữ và truy xuất dữ liệu hiệu quả thường quan trọng hơn tốc độ viết code.

3. **Tối ưu hóa hiệu suất**: Các yếu tố như network latency, database queries, và caching thường ảnh hưởng lớn hơn đến trải nghiệm người dùng cuối.

4. **Quy trình làm việc nhóm**: Thời gian dành cho họp hành, code review, và phối hợp giữa các thành viên trong nhóm thường chiếm phần lớn thời gian phát triển.

### Bài học cho lập trình viên hiện đại

Thay vì tập trung vào việc viết code nhanh hơn, các lập trình viên nên chú trọng vào:

- Hiểu rõ vấn đề cần giải quyết trước khi bắt tay vào code
- Sử dụng hiệu quả các công cụ và thư viện có sẵn
- Tối ưu hóa kiến trúc hệ thống
- Cải thiện kỹ năng giao tiếp và làm việc nhóm

Điều này cho thấy tầm quan trọng của tư duy hệ thống trong phát triển phần mềm hiện đại, nơi mà việc viết code chỉ là một phần của toàn bộ quy trình.

## [Building Tiny AI Tools](https://www.seangoedecke.com/building-tiny-ai-tools/)

Trong thời đại mà các mô hình AI lớn đang chiếm sóng, bài viết này mang đến một góc nhìn mới mẻ: đôi khi những công cụ AI nhỏ gọn, tập trung vào một nhiệm vụ cụ thể lại hiệu quả hơn các giải pháp phức tạp.

### Tại sao công cụ AI nhỏ lại hiệu quả?

Các công cụ AI nhỏ (tiny AI tools) có nhiều lợi thế so với các mô hình lớn:

- **Tốc độ xử lý nhanh**: Không cần tải và xử lý qua nhiều layer phức tạp
- **Chi phí thấp**: Ít tốn tài nguyên tính toán và lưu trữ
- **Dễ tùy chỉnh**: Có thể dễ dàng điều chỉnh cho phù hợp với nhu cầu cụ thể
- **Độ chính xác cao**: Khi được huấn luyện tốt cho một nhiệm vụ cụ thể

### Ví dụ thực tế về tiny AI tools

1. **Công cụ phân loại email**: Một mô hình nhỏ chuyên phân loại email quan trọng vs spam
2. **Trình tóm tắt văn bản**: AI nhỏ chuyên tóm tắt các đoạn văn ngắn
3. **Phát hiện lỗi code**: Công cụ AI nhỏ chuyên tìm lỗi syntax hoặc logic trong code
4. **Dịch thuật ngắn**: Dịch các cụm từ hoặc câu ngắn thay vì toàn bộ tài liệu

### Cách xây dựng tiny AI tools

Để xây dựng các công cụ AI nhỏ hiệu quả:

- **Xác định rõ nhiệm vụ**: Tập trung vào một vấn đề cụ thể, không cố gắng làm quá nhiều thứ
- **Sử dụng dữ liệu chất lượng**: Huấn luyện với dữ liệu sạch và phù hợp cho nhiệm vụ đó
- **Tối ưu hóa mô hình**: Sử dụng các kỹ thuật như quantization hoặc pruning để giảm kích thước
- **Đánh giá liên tục**: Kiểm tra hiệu suất và điều chỉnh khi cần thiết

### Bài học cho lập trình viên

1. **Đừng theo đuổi công nghệ lớn khi không cần thiết**: Đôi khi một giải pháp đơn giản lại hiệu quả hơn
2. **Tập trung vào vấn đề thực tế**: Thay vì cố gắng xây dựng một AI "vạn năng"
3. **Tối ưu hóa cho hiệu quả**: Cân nhắc giữa độ phức tạp và hiệu suất thực tế

Điều này cho thấy rằng trong thế giới AI hiện đại, đôi khi "ít hơn lại là nhiều" - những công cụ nhỏ gọn, tập trung có thể mang lại giá trị thực tế lớn hơn các giải pháp phức tạp.

## [Modern Git Commands and Features You Should Be Using](https://martinheinz.dev/blog/109)

Hầu hết chúng ta đều sử dụng Git mỗi ngày, nhưng phần lớn chỉ dừng lại ở các lệnh cơ bản như `add`, `commit`, `push`, `pull` - như thể vẫn đang ở năm 2005. Git đã phát triển rất nhiều kể từ đó, và việc sử dụng các tính năng hiện đại có thể khiến công việc của bạn trở nên dễ dàng hơn rất nhiều.

### 1. `git switch` và `git restore`

**`git switch`** (ra mắt 2019) thay thế `git checkout` cho việc chuyển branch với các kiểm tra an toàn tốt hơn:

```bash
git switch other-branch
git switch -  # Quay lại branch trước đó
git switch remote-branch  # Chuyển sang remote branch và tự động tracking
```

**`git restore`** cho phép khôi phục file về trạng thái trước đó mà không cần `reset` phức tạp:

```bash
# Bỏ stage changes
git restore --staged some-file.py

# Bỏ stage và discard changes
git restore --staged --worktree some-file.py

# Khôi phục file về commit cụ thể
git restore --source HEAD~2 some-file.py
```

### 2. `git sparse-checkout`

Giúp làm việc với monorepo lớn bằng cách chỉ checkout các thư mục cần thiết, tăng tốc độ đáng kể:

```bash
git clone --no-checkout https://github.com/example/monorepo
cd monorepo
git sparse-checkout init --cone
git checkout main  # Chỉ checkout file trong root
git sparse-checkout set service/common  # Chỉ lấy thư mục cần thiết
```

### 3. `git worktree`

Cho phép làm việc với nhiều branch cùng lúc mà không cần clone lại repo:

```bash
git worktree add ../hotfix master  # Tạo worktree mới từ master
cd ../hotfix  # Làm việc độc lập
git worktree list  # Liệt kê các worktree
```

### 4. `git bisect`

Tìm commit gây ra bug bằng binary search - tính năng tồn tại từ 2012 nhưng ít được biết đến:

```bash
git bisect start
git bisect bad HEAD      # Commit hiện tại bị lỗi
git bisect good abc123   # Commit cuối cùng hoạt động tốt
# Git tự động checkout commit ở giữa
git bisect good/bad      # Test và báo cáo kết quả
git bisect reset         # Quay lại commit ban đầu
```

### Bài học quan trọng

Khi gặp vấn đề với Git, thay vì chỉ dựa vào các câu trả lời cũ trên StackOverflow, hãy kiểm tra documentation mới nhất. Git đã phát triển rất nhiều và có thể đã có cách giải quyết tốt hơn, đơn giản hơn cho vấn đề của bạn.

Những công cụ này không chỉ tiết kiệm thời gian mà còn giúp workflow Git trở nên chuyên nghiệp và hiệu quả hơn, đặc biệt khi làm việc với các dự án lớn hoặc trong môi trường nhóm.

_Sau khi trải nghiệm mình nhận thấy Kimi K2 luôn phản hồi nhanh hơn Qwen 3 Coder, dù dùng Cline hay Roo Code, và Roo Code gọi nhiều request hơn Cline, tuy nhiên độ hài lòng về kết quả thì cũng xêm xêm. Vì OpenRouter limit dựa trên số lần request chứ không phải tổng lượng token nên có lẽ mình sẽ chọn Cline + Kimi K2 để dùng tạm mỗi khi Claude Code chạm quota._
